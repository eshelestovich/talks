= Practical Concurrency Tips

== Concurrency is hard
* Not enough synchronization leads to races and deadlocks
* Too much synchronization leads to slow programs

image::race.png[]

== {conceal}
[quote, Martin Logan, Erlang in Action]
____
Make it work, then make it beautiful, then if you really, really have to, make it fast. 90% of the time, if you make it beautiful, it will already be fast.
____

== How to stop a thread ?
[source,java]
----
Thread t = new Thread(() -> {
    while (true) {
        try {
            System.out.println("Working");
            // do some useful work
            TimeUnit.SECONDS.sleep(10L);
        } catch (InterruptedException e) {
            // ignore
            //e.printStackTrace();
        }
    }
});
t.start();
----

== Correct way
[source,java]
----
while (!Thread.currentThread().isInterrupted()) { // <1>
    try {
      // ...
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt(); // <2>
    }
}
...
t.interrupt(); // <3>
----
<1> Check if somebody wants to stop the thread
<2> Re-set interrupted flag for callers
<3> Actual interruption

== Poison pill
[source,java]
----
while (true) {
    Message message = queue.take();
    if (POISON_PILL_MSG.equals(message)) { // <1>
        return;
    }
    System.out.println(message.toString());
    messageCount++;
}
----
<1> Graceful shutdown

== Unstoppable app
[source,java]
----
public static void main(String[] args) {
    ExecutorService executor = Executors.newSingleThreadExecutor();
    executor.submit(() -> System.out.println("Background thread finished."));
    System.out.println("Main thread finished.");
}
----

[source,console]
----
eshelestovich:/$ java UnstoppablePool
Main thread finished.
Background thread finished.
...
----

== Guava
[source,java]
----
ExecutorService executor = MoreExecutors.getExitingExecutorService(
    (ThreadPoolExecutor) Executors.newSingleThreadExecutor());
----

that basically does:

[source,java]
----
executor.setThreadFactory(
  new ThreadFactoryBuilder().setDaemon(true))
----

== Fixed pool, right ?
[source,java]
----
ExecutorService executor = Executors.newFixedThreadPool(8)); // <1>
while (true) {
    executor.execute(() -> {
      println(Thread.currentThread().getName() + " is working");
      Uninterruptibles.sleepUninterruptibly(1L, TimeUnit.SECONDS);
      if (i.getAndIncrement() % 4 == 0) { // <2>
        throw new RuntimeException(); 
      } 
    });
}
----
<1> 8 threads initially
<2> inject 25% errors

== Silent killer
[source,console]
----
pool-1-thread-1 is working
pool-1-thread-2 is working
Exception in thread "pool-1-thread-1" java.lang.RuntimeException
  at UnstoppablePool.lambda$main$0(UnstoppablePool.java:27)
pool-1-thread-4 is working
pool-1-thread-5 is working
pool-1-thread-6 is working
pool-1-thread-8 is working
Exception in thread "pool-1-thread-6" java.lang.RuntimeException
  at UnstoppablePool.lambda$main$0(UnstoppablePool.java:27)
pool-1-thread-9 is working
pool-1-thread-10 is working
----

== Global exception handler
[source,java]
----
Thread.setDefaultUncaughtExceptionHandler(
  new Thread.UncaughtExceptionHandler() {
    public void uncaughtException(Thread t, Throwable e) {
        LOG.error("Thread " + t + " died", e);
    }
  });
----
or bail out:
[source,java]
----
Thread.setDefaultUncaughtExceptionHandler(
  UncaughtExceptionHandlers.systemExit());
----

== RejectedExecutionHandler
[source,java]
----
ThreadPoolExecutor pool = (ThreadPoolExecutor) Executors.newSingleThreadExecutor();
pool.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
----
